{
   渲染步骤:{
    step-desc:"解析HTML以构建dom树--->构建render树--->布局render树--->绘制render树",
    step:{
     1:"浏览器会将HTML解析成一个DOM树，构建DOM树是一个深度遍历的过程，当前节点的所有子节点都构建好以后才会去构建当前节点的下一个兄弟节点",
     2:"将css解析成css规则树",
     3:"根据Dom树和Css规则树来构造render树,render树不等于Dom树，像header和display:none;这种没有具体内容的东西就不在render树中",
     4:"根据render树,浏览器可以计算出网页中有哪些节点,各节点的css以及从属关系,然后计算出每个节点在屏幕中的位置",
     5:"遍历render树绘制页面中的各元素"
    }
   },
   加载HTML页面步骤:{
     1:"用户输入网站，浏览器向服务器发出请求，服务器返回Html文件",
     2:"浏览器开始载入Html代码，发现<head>标签内有一个<link>标签引用外部css文件",
     3:"浏览器又发出css为保护的请求，服务器返回这个css文件",
     4:"css文件获取到以后,浏览器继续载入Html中<body>部分代码",
     5:"浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求，此时浏览器不会等到图片下载完，而是继续加载后面的代码",
     6:"服务器返回图片文件,由于图片占用了一定空间，影响了后面段落的排版，因此浏览器需要回过头来重新渲染这部分代码",
     7:"浏览器发现了一个包含js代码的<script>标签，直接运行该脚本",
     8:"执行js过程中，发现代码中要隐藏某个元素，这是浏览器不得不重新渲染这部分代码",
     9:"整个<html></html>文档暂时加载完成",
     10:"如果切换css，重新请求css，重新加载页面，然后执行渲染过程"
   },
   浏览器向服务器请求资源:{
    desc:"用户用URI[Uniform Resource Identifier统一资源标识符]来制定所请求资源的位置，通过DNS查询，将网址转换为IP地址",
    step:{
      1:"输入网址",
      2:"浏览器查找域名的IP地址",
      3:"浏览器给web服务器发送一个http请求",
      4:"网站服务的永久重定向响应",
      5:"浏览器跟踪重定向地址， 浏览器得到访问的地址，发送另外一个获取请求",
      6:"服务器处理请求，服务器收到获取请求，然后处理并返回一个响应",
      7:"服务器发回一个html响应",
      8:"浏览器开始显示html",
      9:"浏览器发送请求"
    }
   },
   减少http请求:{
    1:"页面简洁,包含较少的图片和脚本",
    2:"将多个图片合并为一个文件，利用css背景图片偏移计数将其呈现在网页中，避免对各图片下载",
    3:"合并和压缩javacript脚本和css样式表",
    4:"充分利用http的浏览器端Cache策略，减少重复下载"
   },
   URl到页面呈现:{
    1:"查看缓存(浏览器缓存、系统缓存、路由器缓存)，如果有直接访问",
    2:"如果没有，DNS服务器进行域名解析，解析成ip地址",
    3:"通过ip地址找到服务器，进行TCP链接，完成三次握手",
    4:"浏览器向服务器发送http请求",
    5:"服务器响应，将响应报文通过TCP发送回浏览器",
    6:"对响应进行解码，根据资源类型决定如何处理",
    7:"如果是HTML文档，构建Dom树，下载css、js资源。构建渲染树，布局、绘制"
   },
   TCP:{
     1:"客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认",
     2:"服务器收到syn包，必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(syn=k),即SYN+ACK包，此时服务器进入SYN_RECV状态",
     3:"客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此包发送完毕，客户端和服务器进入ESTABLISHED状态,完成三次握手"
   },
   HTTP处理过程:{
    1:"用户输入URL，浏览器获取URL",
    2:"浏览器进行DNS解析",
    3:"根据解析出的IP地址+端口，浏览器（应用层）发起http请求，请求中携带（请求头header、请求体body）",
    4:"请求到达传输层，tcp协议为传输报文提供可靠的字节流传输服务，它通过三次握手等手段保证传输过程的安全可靠。通过对大块数据的分割
    成一个个报文段的方式提供给大量数据的便携传输",
    5:"到网络层，网络层通过ARP寻址得到接收方的Mac地址，IP协议把在传输层被分割成一个个数据包传送接收方",
    6:"数据到底数据链路层，请求阶段完成",
    7:"接收方在数据链路层收到数据包之后，层层传递到应用层，接收方应用程序就获得到请求报文",
    8:"接收方收到发送方的Http请求后，进行请求文件资源（如html页面）的寻找并响应报文",
    9:"发送方收到响应报文后，如果报文中的状态码表示请求成功，则接受返回的资源"
   },
   浏览器查找域名的IP地址:{
    1:"请求发起后，浏览器首先会解析这个域名，首先它会查看本地硬盘的hosts文件，看看其中有没有和这个域名对应的规则，
    如果有的话就直接使用hosts文件里的ip地址",
    2:"如果1失败，浏览器会发出一个dns请求到本地dns服务器",
    3:"查询你输入网址的dns请求到达本地dns服务器之后，本地dns服务器会首先查询它的缓存记录，如果缓存中有此条记录，就直接返回结果，
    此过程是递归的方式进行查询。如果没有，本地dns服务器还要向dns根服务器进行查询",
    4:"根dns服务器没有记录具体的域名和ip地址的对应关系，而是告诉本地dns服务器，你可以到域服务器上继续查询，并给出域服务器的地址。
    这种过程是迭代过程",
    5:"本地Dns服务器继续向域名服务器发出请求，在这个例子中，请求的对象是.com域名服务器。.com域服务器收到请求之后，
    也不会直接返回域名和ip地址的对应关系，而是告诉本地dns服务器，你的域名的解析服务器的地址",
    6:"最后，本地dns服务器向域名的解析服务器发出请求，这时就能收到一个域名和ip地址对应关系，本地dns服务器不仅把ip地址返回给用户电脑，
    还要把这个对应关系保存在缓存中，以备下次用户查询时，可以直接返回结果，加快网络访问"
   }
}
