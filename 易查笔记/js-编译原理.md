# 作用域
js的代码先解构，然后在作用域内通过LHS(找到变量的本身)和RHS(取到源值)
 * 引擎
 * 编译器
 * 作用域
  
引擎在RHS之前对作用域进行变量询问，一层层的从当前到最顶层，如果找不到就异常
引擎在LHS找编译器找到变量的声明
引擎对变量RHS时再次向作用域确认一下
 * 标志符  
   js变量
 * 遮蔽效应  
  
  作用域会从最接近的位置开始查找，找到第一个匹配的标志符停止
  对于foo.bar.baz这样的，首先找到foo的声明，也就是只查找一级标志符

* with(摒弃的)
  ```javascript
   with(obj){
       a=1;
       b=2;
       c=3;
   }
   //obj={ a:1,b:2,c:3}
   function foo(obj){
       with(obj){
           a=2;
       }
   }
   var a1={
       a:3
   }
   var a2={
       b:3
   }
   foo(a1);
   a1.a  //2
   foo(a2);
   a2.a //undefined
   a //2
   //导致全局变量污染
  //eval with 虽然可以出其不意的做到一些事情，但是性能较差，而且很难优化（提升阅读和异常跟踪）

  ```
 ## 函数作用域
  属于函数的全部变量都可以在函数的范围内使用及复用
## 函数表达式和函数声明
 * (function foo(){..})
   表达式中的标志符
 * 函数表达式可以匿名  
    * 没有名称标志符
    * 函数声明不可省略函数名
 * IIFE 立即执行函数表达式
   * (function foo(){..})()  
   * (function(){..}())
   * UMD
   ```javascript
   (function IIFE(def){
       def(window);
   })(function def(global){

   });
   ```
立即执行函数表达式
  * for(var i=0;i<10;i++)   
   js无{} 块状作用域
   with try/catch(catch的参数，只能内部使用) 可以实现块状作用域
  i会变成全部变量

  * let 可以实现垃圾回收  
  因为一些事件需要作用域内的变量，会形成一个闭包覆盖整个作用域，所以可能导致一些占有大量内存的变量未使用却也不能被回收，如果定义成let，而且未被引用，就会释放

 * 闭包和作用域闭包
 * 动态作用域 this（基于词法作用域）  
js无动态作用域
  
   
  